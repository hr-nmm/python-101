# Design Patterns

Design patterns provide reusable solutions to common software design problems. They help you create flexible, maintainable, and scalable software architectures.

This folder explores design patterns classified into three main categories:

## 1. Creational Patterns

- Purpose: Encapsulate object creation mechanisms, promoting flexibility and loose coupling.
- Focus: How objects are created.
- Common Creational Patterns:

- Factory Method: Define an interface for creating objects, but let subclasses decide which class to instantiate. (Image: UML diagram of Factory Method)
- Abstract Factory: Provide an interface for creating families of related objects without specifying their concrete classes. (Image: UML diagram of Abstract Factory)
- Builder: Separate the construction of a complex object from its representation, allowing for different representations. (Image: UML diagram of Builder)
- Prototype: Create new objects by cloning existing ones, avoiding costly initialization processes. (Image: UML diagram of Prototype)
- Singleton: Ensure a class has only one instance, providing a global point of access. (Image: UML diagram of Singleton)
## 2. Structural Patterns

- Purpose: Compose objects into larger structures, often to achieve new functionality.
- Focus: How objects are composed to form larger structures.
- Common Structural Patterns:

- Adapter: Convert the interface of a class to match another expected interface. (Image: UML diagram of Adapter)
- Bridge: Decouple an abstraction from its implementation, allowing both to vary independently. (Image: UML diagram of Bridge)
- Composite: Treat individual objects and compositions of objects uniformly. (Image: UML diagram of Composite)
- Decorator: Add responsibilities to objects dynamically without affecting other objects. (Image: UML diagram of Decorator)
- Facade: Provide a simplified interface to a complex subsystem. (Image: UML diagram of Facade)
## 3. Behavioral Patterns

- Purpose: Define how objects interact and distribute responsibility.
- Focus: How objects communicate with each other.
- Common Behavioral Patterns:

- Observer: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. (Image: UML diagram of Observer)
- Strategy: Define a family of algorithms, encapsulate each one, and make them interchangeable. (Image: UML diagram of Strategy)
- State: Allow an object to alter its behavior when its internal state changes. (Image: UML diagram of State)
- Template Method: Define the skeleton of an algorithm in a method, deferring some steps to subclasses. (Image: UML diagram of Template Method)
- Chain of Responsibility: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. (Image: UML diagram of Chain of Responsibility)


